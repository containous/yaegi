package interp

// Code generated by 'go run ../cmd/genop/genop.go'. DO NOT EDIT.

import "reflect"

// Arithmetic operators

func add(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.String:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			dest(f).SetString(v0(f).String() + v1(f).String())
			return next
		}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i + j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i + j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetFloat(i + j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			dest(f).SetComplex(v0(f).Complex() + v1(f).Complex())
			return next
		}
	}
}

func and(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i & j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i & j)
			return next
		}
	}
}

func andnot(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i &^ j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i &^ j)
			return next
		}
	}
}

func mul(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i * j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i * j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetFloat(i * j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			dest(f).SetComplex(v0(f).Complex() * v1(f).Complex())
			return next
		}
	}
}

func or(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i | j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i | j)
			return next
		}
	}
}

func quo(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i / j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i / j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetFloat(i / j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			dest(f).SetComplex(v0(f).Complex() / v1(f).Complex())
			return next
		}
	}
}

func rem(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i % j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i % j)
			return next
		}
	}
}

func shl(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i << j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i << j)
			return next
		}
	}
}

func shr(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i >> j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i >> j)
			return next
		}
	}
}

func sub(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i - j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i - j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetFloat(i - j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			dest(f).SetComplex(v0(f).Complex() - v1(f).Complex())
			return next
		}
	}
}

func xor(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetInt(i ^ j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			_, i := v0(f)
			_, j := v1(f)
			dest(f).SetUint(i ^ j)
			return next
		}
	}
}

// Assign operators

func addAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.String:
		v0 := genValueString(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, s := v0(f)
			v.SetString(s + v1(f).String())
			return next
		}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i + j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i + j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetFloat(i + j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() + v1(f).Complex())
			return next
		}
	}
}

func andAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i & j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i & j)
			return next
		}
	}
}

func andnotAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i &^ j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i &^ j)
			return next
		}
	}
}

func mulAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i * j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i * j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetFloat(i * j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() * v1(f).Complex())
			return next
		}
	}
}

func orAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i | j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i | j)
			return next
		}
	}
}

func quoAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i / j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i / j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetFloat(i / j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() / v1(f).Complex())
			return next
		}
	}
}

func remAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i % j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i % j)
			return next
		}
	}
}

func shlAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i << j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i << j)
			return next
		}
	}
}

func shrAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i >> j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i >> j)
			return next
		}
	}
}

func subAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i - j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i - j)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetFloat(i - j)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() - v1(f).Complex())
			return next
		}
	}
}

func xorAssign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetInt(i ^ j)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			_, j := v1(f)
			v.SetUint(i ^ j)
			return next
		}
	}
}

func dec(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetInt(i - 1)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v0 := genValueUint(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetUint(i - 1)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetFloat(i - 1)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() - 1)
			return next
		}
	}
}

func inc(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetInt(i + 1)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v0 := genValueUint(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetUint(i + 1)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetFloat(i + 1)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() + 1)
			return next
		}
	}
}

func equal(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 == s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 == s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 == s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 == s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 == s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 == s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 == s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 == s1)
				return tnext
			}
		}
	}
}

func greater(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 > s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 > s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 > s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 > s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 > s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 > s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 > s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 > s1)
				return tnext
			}
		}
	}
}

func greaterEqual(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 >= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 >= s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 >= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 >= s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 >= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 >= s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 >= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 >= s1)
				return tnext
			}
		}
	}
}

func lower(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 < s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 < s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 < s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 < s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 < s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 < s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 < s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 < s1)
				return tnext
			}
		}
	}
}

func lowerEqual(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 <= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 <= s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 <= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 <= s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 <= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 <= s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 <= s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 <= s1)
				return tnext
			}
		}
	}
}

func notEqual(n *Node) {
	tnext := getExec(n.tnext)

	switch t0, t1 := n.child[0].typ, n.child[1].typ; {
	case isString(t0) || isString(t1):
		v0 := genValueString(n.child[0])
		v1 := genValueString(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 != s1 {
					return tnext
				}
				return fnext
			}
		} else {
			i := n.findex
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				f.data[i].SetBool(s0 != s1)
				return tnext
			}
		}
	case isFloat(t0) || isFloat(t1):
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 != s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 != s1)
				return tnext
			}
		}
	case isUint(t0) || isUint(t1):
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 != s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 != s1)
				return tnext
			}
		}
	default:
		v0 := genValueInt(n.child[0])
		v1 := genValueInt(n.child[1])
		if n.fnext != nil {
			fnext := getExec(n.fnext)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				if s0 != s1 {
					return tnext
				}
				return fnext
			}
		} else {
			dest := genValue(n)
			n.exec = func(f *Frame) Builtin {
				_, s0 := v0(f)
				_, s1 := v1(f)
				dest(f).SetBool(s0 != s1)
				return tnext
			}
		}
	}
}
