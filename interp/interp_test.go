// Code Generated by ../_test/gen_example.sh. DO NOT EDIT.

package interp_test

import (
	"github.com/containous/dyngo/interp"
	"github.com/containous/dyngo/stdlib"
)

func Example_a1() {
	src := `
package main

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	println(a[1]) // 2
	for i, v := range a {
		println(v)
		if i == 3 {
			break
		}
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 1
	// 2
	// 3
	// 4
}

func Example_a10() {
	src := `
package main

type Sample struct {
	Name string
}

var samples = []Sample{}

func f(i int) {
	println(samples[i].Name)
}

func main() {
	samples = append(samples, Sample{Name: "test"})
	f(0)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// test
}

func Example_a11() {
	src := `
package main

func main() {
	a := []int{1, 2, 3, 4}
	for _, v := range a {
		println(v)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
	// 2
	// 3
	// 4
}

func Example_a12() {
	src := `
package main

import "fmt"

func main() {
	var buf [12]int
	fmt.Println(buf[0])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0
}

func Example_a13() {
	src := `
package main

type T1 struct {
	num []int
}

func main() {
	a := T1{[]int{1, 3, 5}}
	for i, v := range a.num {
		println(i, v)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 1
	// 1 3
	// 2 5
}

func Example_a14() {
	src := `
package main

import "fmt"

const size = 12

func main() {
	var buf [size]int
	fmt.Println(buf)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [0 0 0 0 0 0 0 0 0 0 0 0]
}

func Example_a15() {
	src := `
package main

import "fmt"

const size = 12

func main() {
	var buf [size]int
	fmt.Println(buf[:])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [0 0 0 0 0 0 0 0 0 0 0 0]
}

func Example_a16() {
	src := `
package main

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	println(a[1]) // 2
	for k := 0; k < 2; k++ {
		for i, v := range a {
			println(v)
			if i == 3 {
				break
			}
		}
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 1
	// 2
	// 3
	// 4
	// 1
	// 2
	// 3
	// 4
}

func Example_a17() {
	src := `
package main

import "fmt"

func main() {
	a := make([]int, 2, 7)
	fmt.Println(a, len(a), cap(a))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [0 0] 2 7
}

func Example_a18() {
	src := `
package main

func main() {
	a := []int64{1, 2, 3, 4}
	for _, v := range a {
		println(v)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
	// 2
	// 3
	// 4
}

func Example_a19() {
	src := `
package main

func main() {
	var buf [bsize]byte
	println(len(buf))
}

const bsize = 10
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 10
}

func Example_a2() {
	src := `
package main

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	a[1] = 5
	println(a[1]) // 2
	for i, v := range a {
		println(v)
		if i == 3 {
			break
		}
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
	// 1
	// 5
	// 3
	// 4
}

func Example_a3() {
	src := `
package main

import "fmt"

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println(a[2:])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [3 4 5 6]
}

func Example_a4() {
	src := `
package main

import "fmt"

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println(a[2:4])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [3 4]
}

func Example_a5() {
	src := `
package main

import "fmt"

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println(a[:4])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1 2 3 4]
}

func Example_a6() {
	src := `
package main

import "fmt"

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println(a[:])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1 2 3 4 5 6]
}

func Example_a7() {
	src := `
package main

import "fmt"

func main() {
	a := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println(len(a))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 6
}

func Example_a8() {
	src := `
package main

import "fmt"

func main() {
	//a := []int{1, 2}
	a := make([]int, 2)
	//a[0] = 1
	//a[1] = 2
	fmt.Println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [0 0]
}

func Example_a9() {
	src := `
package main

import "fmt"

//var (
//	samples = []int{}
//	b       = 1
//)

func main() {
	var samples = []int{}
	samples = append(samples, 1)
	fmt.Println(samples)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1]
}

func Example_and() {
	src := `
package main

func main() {
	a, b := 1, 2

	if f1() && f2() {
		println(a, b)
	}
}

func f1() bool {
	println("f1")
	//return true
	return 0 == 0
}

func f2() bool {
	println("f2")
	//return false
	return 1 == 0
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1
	// f2
}

func Example_and0() {
	src := `
package main

func main() {
	a, b := 1, 2

	if f2() && f1() {
		println(a, b)
	}
}

func f1() bool {
	println("f1")
	return true
}

func f2() bool {
	println("f2")
	return false
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f2
}

func Example_and1() {
	src := `
package main

func main() {
	a := f2() && f1()
	println(a)
}

func f1() bool {
	println("f1")
	return true
}

func f2() bool {
	println("f2")
	return false
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f2
	// false
}

func Example_assign() {
	src := `
package main

func main() {
	a, b := 1, 2 // Multiple assign
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 2
}

func Example_bin() {
	src := `
package main

import "fmt"

func main() {
	f := fmt.Println
	f("Hello")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello
}

func Example_bltn() {
	src := `
package main

func main() {
	println("Hello")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello
}

func Example_bltn0() {
	src := `
package main

func main() {
	f := println
	f("Hello")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_bool() {
	src := `
package main

import "fmt"

func main() {
	fmt.Println(false, true)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// false true
}

func Example_bool0() {
	src := `
package main

import "fmt"

func main() {
	fmt.Println(true)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// true
}

func Example_bool1() {
	src := `
package main

type T struct {
	v bool
}

func main() {
	a := T{}
	if a.v {
		println("ok")
	} else {
		println("nok")
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// nok
}

func Example_bool2() {
	src := `
package main

type T struct {
	v bool
}

func main() {
	a := &T{}
	if a.v {
		println("ok")
	} else {
		println("nok")
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// nok
}

func Example_bool3() {
	src := `
package main

func main() {
	m := map[int]bool{0: false, 1: true}
	if m[0] {
		println(0)
	} else {
		println(1)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_bool4() {
	src := `
package main

func main() {
	m := []bool{false, true}
	if m[0] {
		println(0)
	} else {
		println(1)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_bool5() {
	src := `
package main

func main() {
	var b bool
	m := &b

	if *m {
		println(0)
	} else {
		println(1)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_chan0() {
	src := `
package main

type Channel chan string

func send(c Channel) { c <- "ping" }

func main() {
	channel := make(Channel)
	go send(channel)
	msg := <-channel
	println(msg)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// ping
}

func Example_chan1() {
	src := `
package main

func send(c chan<- string) { c <- "ping" }

func main() {
	channel := make(chan string)
	go send(channel)
	msg := <-channel
	println(msg)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// ping
}

func Example_chan2() {
	src := `
package main

import "fmt"

func main() {
	messages := make(chan string)

	go func() { messages <- "ping" }()

	msg := <-messages
	fmt.Println(msg)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// ping
}

func Example_chan3() {
	src := `
package main

func send(c chan<- int32) { c <- 123 }

func main() {
	channel := make(chan int32)
	go send(channel)
	msg := <-channel
	println(msg)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 123
}

func Example_chan4() {
	src := `
package main

func send(c chan<- bool) { c <- false }

func main() {
	channel := make(chan bool)
	go send(channel)
	if <-channel {
		println("ok")
	} else {
		println("nok")
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// nok
}

func Example_chan5() {
	src := `
package main

import "time"

func main() {

	// For our example we'll select across two channels.
	c1 := make(chan string)
	c2 := make(chan string)

	// Each channel will receive a value after some amount
	// of time, to simulate e.g. blocking RPC operations
	// executing in concurrent goroutines.
	go func() {
		//time.Sleep(1 * time.Second)
		time.Sleep(1e9)
		c1 <- "one"
	}()
	go func() {
		time.Sleep(2e9)
		c2 <- "two"
	}()

	msg1 := <-c1
	println(msg1)

	msg2 := <-c2
	println(msg2)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_chan6() {
	src := `
package main

func send(c chan<- int32) { c <- 123 }

func main() {
	channel := make(chan int32)
	go send(channel)
	msg, ok := <-channel
	println(msg, ok)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_cli1() {
	src := `
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
)

func client(uri string) {
	resp, err := http.Get(uri)
	if err != nil {
		log.Fatal(err)
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(body))
}

func server(ln net.Listener, ready chan bool) {
	http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
		var r1 *http.Request = r
		fmt.Fprintln(w, "Welcome to my website!", r1.RequestURI)
	})

	go http.Serve(ln, nil)
	ready <- true
}

func main() {
	ln, err := net.Listen("tcp", ":0")
	if err != nil {
		log.Fatal(err)
	}
	defer ln.Close()

	ready := make(chan bool)
	go server(ln, ready)
	<-ready

	client(fmt.Sprintf("http://%s/hello", ln.Addr().String()))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Welcome to my website! /hello
}

func Example_cli3() {
	src := `
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httptest"
)

func client(uri string) {
	resp, err := http.Get(uri)
	if err != nil {
		log.Fatal(err)
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(body))
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Welcome to my website!")
	})

	server := httptest.NewServer(mux)
	defer server.Close()

	client(server.URL)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Welcome to my website!
}

func Example_closure0() {
	src := `
package main

type adder func(int, int) int

func genAdd(k int) adder {
	return func(i, j int) int {
		return i + j + k
	}
}

func main() {
	f := genAdd(5)
	println(f(3, 4))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 12
}

func Example_closure1() {
	src := `
package main

type adder func(int, int) int

func genAdd(k int) adder {
	return func(i, j int) int {
		return i + j + k
	}
}

func main() {
	f := genAdd(5)
	g := genAdd(8)
	println(f(3, 4))
	println(g(3, 4))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 12
	// 15
}

func Example_closure2() {
	src := `
package main

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum = sum + x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		println(pos(i), neg(-2*i))
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 0
	// 1 -2
	// 3 -6
	// 6 -12
	// 10 -20
	// 15 -30
	// 21 -42
	// 28 -56
	// 36 -72
	// 45 -90
}

func Example_closure3() {
	src := `
package main

type T1 struct {
	Name string
}

func (t *T1) genAdd(k int) func(int) int {
	return func(i int) int {
		println(t.Name)
		return i + k
	}
}

var t = &T1{"test"}

func main() {
	f := t.genAdd(4)
	println(f(5))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// test
	// 9
}

func Example_closure4() {
	src := `
package main

type T1 struct {
	Name string
}

func (t *T1) genAdd(k int) func(int) int {
	return func(i int) int {
		println(t.Name)
		return i + k
	}
}

var t = T1{"test"}

func main() {
	f := t.genAdd(4)
	println(f(5))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// test
	// 9
}

func Example_closure5() {
	src := `
package main

type T1 struct {
	Name string
}

func (t T1) genAdd(k int) func(int) int {
	return func(i int) int {
		println(t.Name)
		return i + k
	}
}

var t = T1{"test"}

func main() {
	f := t.genAdd(4)
	println(f(5))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// test
	// 9
}

func Example_closure6() {
	src := `
package main

type T1 struct {
	Name string
}

func (t *T1) genAdd(k int) func(int) int {
	return func(i int) int {
		println(t.Name)
		return i + k
	}
}

var t = &T1{"test"}

func main() {
	f := t.genAdd(4)
	println(f(5))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// test
	// 9
}

func Example_comp0() {
	src := `
package main

func main() {
	println(2 < 2.4)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// true
}

func Example_const0() {
	src := `
package main

const (
	a = iota
	b
)

func main() {
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 1
}

func Example_const1() {
	src := `
package main

type T struct {
	a int
	b string
}

var t = T{1, "hello"}

func main() {
	println(t.a, t.b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 hello
}

func Example_const2() {
	src := `
package main

func main() {
	println(a)
}

const a = "hello"
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
}

func Example_const3() {
	src := `
package main

const a, b, c int = 1, 2, 3

func main() { println(a, b, c) }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 2 3
}

func Example_cont() {
	src := `
package main

func main() {
	for i := 0; i < 10; i++ {
		if i < 5 {
			continue
		}
		println(i)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
	// 6
	// 7
	// 8
	// 9
}

func Example_cont0() {
	src := `
package main

func main() {
	i := 0
	for {
		if i > 10 {
			break
		}
		i++
		if i < 5 {
			continue
		}
		println(i)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
	// 6
	// 7
	// 8
	// 9
	// 10
	// 11
}

func Example_cont1() {
	src := `
package main

func main() {
	i := 0
	for {
		if i > 10 {
			break
		}
		if i < 5 {
			i++
			continue
		}
		println(i)
		i++
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
	// 6
	// 7
	// 8
	// 9
	// 10
}

func Example_context() {
	src := `
package main

import "context"

func get(ctx context.Context, k string) string {
	var r string
	if v := ctx.Value(k); v != nil {
		r = v.(string)
	}
	return r
}

func main() {
	ctx := context.WithValue(context.Background(), "hello", "world")
	println(get(ctx, "hello"))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// world
}

func Example_context2() {
	src := `
package main

import "context"

func get(ctx context.Context, k string) string {
	var r string
	var ok bool
	if v := ctx.Value(k); v != nil {
		r, ok = v.(string)
		println(ok)
	}
	return r
}

func main() {
	ctx := context.WithValue(context.Background(), "hello", "world")
	println(get(ctx, "hello"))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// true
	// world
}

func Example_defer0() {
	src := `
package main

import "fmt"

func main() {
	println("hello")
	defer fmt.Println("bye")
	defer fmt.Println("au revoir")
	println("world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
	// world
	// au revoir
	// bye
}

func Example_defer1() {
	src := `
package main

import "fmt"

func main() {
	println("hello")
	defer func() {
		fmt.Println("bye")
	}()
	println("world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
	// world
	// bye
}

func Example_defer2() {
	src := `
package main

import "fmt"

func main() {
	println("hello")
	i := 12
	defer func() {
		fmt.Println("i:", i)
	}()
	i = 20
	println("world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
	// world
	// i: 20
}

func Example_defer3() {
	src := `
package main

import (
	"net/http"
	"net/http/httptest"
)

func main() {
	println("hello")
	mux := http.NewServeMux()
	server := httptest.NewServer(mux)
	defer server.Close()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
}

func Example_export0() {
	src := `
package main

func Test() {
	println("Hello from test")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_export1() {
	src := `
package sample

type Sample struct{ Name string }

func (s *Sample) Test() {
	println("Hello from test", s.Name)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_factor() {
	src := `
package main

import (
	"fmt"
	"math/big"
)

func main() {
	// 157 bit n = pq with p ~= 78 bits
	n := big.NewInt(0)
	n.SetString("273966616513101251352941655302036077733021013991", 10)

	i := big.NewInt(0)
	// Set i to be p - 10e6
	i.SetString("496968652506233112158689", 10)

	// Move temp big int out here so no possible GC thrashing
	temp := big.NewInt(0)
	// Avoid creating the new bigint each time
	two := big.NewInt(2)
	for {
		// Check if the odd number is a divisor of n
		temp.Mod(n, i)
		if temp.Sign() == 0 {
			fmt.Println(i)
			break
		}

		i.Add(i, two)
	}
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_fib() {
	src := `
package main

// Compute fibonacci numbers, no memoization
func fib(n int) int {
	if n < 2 {
		return n
	}
	return fib(n-2) + fib(n-1)
}

func main() {
	println(fib(35))
	//println(fib(10))
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_fib0() {
	src := `
package main

// Compute fibonacci numbers, no memoization
func fib(n int) int {
	if n < 2 {
		return n
	}
	return fib(n-2) + fib(n-1)
}

func main() {
	println(fib(4))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_for0() {
	src := `
package main

func main() {
	i := 0
	//for ;i >= 0; i++ {
	for {
		if i > 5 {
			break
		}
		println(i)
		i++
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0
	// 1
	// 2
	// 3
	// 4
	// 5
}

func Example_for1() {
	src := `
package main

func main() {
	i := 0
	for i < 10 {
		if i > 4 {
			break
		}
		println(i)
		i++
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0
	// 1
	// 2
	// 3
	// 4
}

func Example_for2() {
	src := `
package main

func main() {
	for i := 2; ; i++ {
		println(i)
		if i > 3 {
			break
		}
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 3
	// 4
}

func Example_for3() {
	src := `
package main

import (
	"fmt"
	"sort"
)

func main() {
	m := map[string][]string{
		"hello": []string{"foo", "bar"},
		"world": []string{"truc", "machin"},
	}

	var content []string

	for key, values := range m {
		for _, value := range values {
			content = append(content, key+value)
		}
	}

	sort.Strings(content)
	fmt.Println(content)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [hellobar hellofoo worldmachin worldtruc]
}

func Example_fun() {
	src := `
package main

func f(i int) int { return i + 15 }

func main() {
	println(f(4))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 19
}

func Example_fun2() {
	src := `
package main

type Coord struct{ x, y int }

func f(c Coord) int { return c.x + c.y }

func main() {
	c := Coord{3, 4}
	println(f(c))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7
}

func Example_fun3() {
	src := `
package main

type Coord struct{ x, y int }

func f(i, j int, c Coord) int { return i*c.x + j*c.y }

func main() {
	c := Coord{3, 4}
	println(f(2, 3, c))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 18
}

func Example_fun4() {
	src := `
package main

func f() {}

func main() {
	f()
	println("ok")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// ok
}

func Example_fun5() {
	src := `
package main

func f(i int64) {
	println(i)
}

func main() {
	f(34)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 34
}

func Example_goroutine() {
	src := `
package main

func f() {
	println("in goroutine f")
}

func main() {
	go f()
	//sleep(100)
	println("in main")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_heap() {
	src := `
// This example demonstrates an integer heap built using the heap interface.
package main

import (
	"container/heap"
	"fmt"
)

// An IntHeap is a min-heap of ints.
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
	// Push and Pop use pointer receivers because they modify the slice's length,
	// not just its contents.
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

// This example inserts several ints into an IntHeap, checks the minimum,
// and removes them in order of priority.
func main() {
	h := &IntHeap{2, 1, 5}
	heap.Init(h)
	heap.Push(h, 3)
	fmt.Printf("minimum: %d\n", (*h)[0])
	for h.Len() > 0 {
		fmt.Printf("%d ", heap.Pop(h))
	}
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_if() {
	src := `
package main

func main() {
	if a := f(); a > 0 {
		println(a)
	}
}

func f() int { return 1 }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_import0() {
	src := `
package main

import "fmt"

func main() {
	fmt.Println("Hello", 42)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello 42
}

func Example_import1() {
	src := `
package main

import f "fmt"

func main() {
	f.Println("Hello", 42)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello 42
}

func Example_import2() {
	src := `
package main

import . "fmt"

func main() {
	Println("Hello", 42)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello 42
}

func Example_inc() {
	src := `
package main

func main() {
	i := 2
	//i++
	i = i + 1
	println(i)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_init0() {
	src := `
package main

func init() {
	println("Hello from init 1")
}

func init() {
	println("Hello from init 2")
}

func main() {
	println("Hello from main")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello from init 1
	// Hello from init 2
	// Hello from main
}

func Example_interface0() {
	src := `
package main

type sample struct {
	count int
}

func run(inf interface{}, name string) {
	x := inf.(sample)
	println(x.count, name)
}

func main() {
	a := sample{2}
	println(a.count)
	run(a, "truc")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_io0() {
	src := `
package main

import (
	"crypto/rand"
	"fmt"
	"io"
)

func main() {
	var buf [16]byte
	fmt.Println(buf)
	io.ReadFull(rand.Reader, buf[:])
	//io.ReadFull(rand.Reader, buf)
	fmt.Println(buf)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_io1() {
	src := `
package main

import (
	"encoding/base64"
	"fmt"
)

func main() {
	var buf [4]byte
	s := base64.RawStdEncoding.EncodeToString(buf[:])
	fmt.Println(s)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// AAAAAA
}

func Example_iota() {
	src := `
package main

import "fmt"

const (
	Foo = iota
	Bar
	Baz
)

const (
	Asm = iota
	C
	Java
	Go
)

func main() {
	fmt.Println(Foo, Bar, Baz)
	fmt.Println(Asm, C, Java, Go)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 1 2
	// 0 1 2 3
}

func Example_iota0() {
	src := `
package main

import "fmt"

func main() {
	const (
		Foo = iota
		Bar
		Baz
	)

	const (
		Asm = iota
		C
		Java
		Go
	)

	fmt.Println(Foo, Bar, Baz)
	fmt.Println(Asm, C, Java, Go)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 1 2
	// 0 1 2 3
}

func Example_ioutil() {
	src := `
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	_, err := ioutil.ReadFile("__NotExisting__")
	if err != nil {
		fmt.Println(err.Error())
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// open __NotExisting__: no such file or directory
}

func Example_ioutil0() {
	src := `
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

func main() {
	r := strings.NewReader("Go is a general-purpose language designed with systems programming in mind.")

	b, err := ioutil.ReadAll(r)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s", b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Go is a general-purpose language designed with systems programming in mind.
}

func Example_l2() {
	src := `
package main

func main() {
	for a := 0; a < 20000; a++ {
		if (a & 0x8ff) == 0x800 {
			println(a)
		}
	}
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_l3() {
	src := `
package main

//func myprint(i int) { println(i) }

func main() {
	for a := 0; a < 20000000; a++ {
		if a&0x8ffff == 0x80000 {
			println(a)
			//myprint(a)
		}
	}
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_l4() {
	src := `
package main

func main()       { println(f(5)) }
func f(i int) int { return i + 1 }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 6
}

func Example_l5() {
	src := `
package main

//func myprint(i int) { println(i) }

func main() {
	for a := 0; a < 20000000; {
		if a&0x8ffff == 0x80000 {
			println(a)
		}
		a = a + 1
	}
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_make() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

func main() {
	h := make(http.Header)
	fmt.Println("h:", h)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// h: map[]
}

func Example_map() {
	src := `
package main

type Dict map[string]string

func main() {
	dict := make(Dict)
	dict["truc"] = "machin"
	println(dict["truc"])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// machin
}

func Example_map2() {
	src := `
package main

func main() {
	dict := make(map[string]string)
	dict["truc"] = "machin"
	println(dict["truc"])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// machin
}

func Example_map3() {
	src := `
package main

func main() {
	dict := map[string]string{}
	dict["truc"] = "machin"
	println(dict["truc"])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// machin
}

func Example_map4() {
	src := `
package main

func main() {
	dict := map[string]string{"bidule": "machin", "truc": "bidule"}
	dict["hello"] = "bonjour"
	println(dict["bidule"])
	println(dict["hello"])
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// machin
	// bonjour
}

func Example_map5() {
	src := `
package main

import "fmt"

func main() {
	dict := map[string]string{"bidule": "machin", "truc": "bidule"}
	r, ok := dict["xxx"]
	fmt.Println(r, ok)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	//  false
}

func Example_map6() {
	src := `
package main

func main() {
	dict := map[string]string{"bidule": "machin"}
	for k, v := range dict {
		println(k, v)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// bidule machin
}

func Example_map7() {
	src := `
package main

func main() {
	dict := map[int32]int64{13: 733}
	for k, v := range dict {
		println(k, v)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 13 733
}

func Example_math0() {
	src := `
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.Cos(math.Pi))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// -1
}

func Example_method() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

func main() {
	o := Coord{3, 4}
	println(o.dist())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method0() {
	src := `
package main

import "fmt"

type Foo struct {
}

func (Foo) Call() {
	fmt.Println("Foo Called")
}

type Bar struct {
	Foo
}

type Baz struct {
	Foo
}

func (Baz) Call() {
	fmt.Println("Baz Called")
}

func main() {
	Foo{}.Call()
	Bar{}.Call()
	Baz{}.Call()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Foo Called
	// Foo Called
	// Baz Called
}

func Example_method1() {
	src := `
package main

type Sample struct {
	Name string
}

func (s *Sample) foo(i int) {
	println("in foo", s.Name, i)
}

func main() {
	sample := Sample{"hello"}
	s := &sample
	s.foo(3)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// in foo hello 3
}

func Example_method10() {
	src := `
package main

type T int

func (t T) foo() { println("foo", t) }

func main() {
	var t T = 2
	t.foo()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// foo 2
}

func Example_method11() {
	src := `
package main

func main() {
	o := &Coord{3, 4}
	println(o.dist())
}

func (c *Coord) dist() int { return c.x*c.x + c.y*c.y }

type Coord struct {
	x, y int
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method12() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

func main() {
	o := Coord{3, 4}
	f := o.dist
	println(f())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method13() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

type Point struct {
	Coord
	z int
}

func main() {
	o := Point{Coord{3, 4}, 5}
	f := o.dist
	println(f())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method14() {
	src := `
package main

func main() {
	o := Coord{3, 4}
	println(o.dist())
}

func (c *Coord) dist() int { return c.x*c.x + c.y*c.y }

type Coord struct {
	x, y int
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method15() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

func main() {
	o := &Coord{3, 4}
	println(o.dist())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method2() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

type Point struct {
	Coord
	z int
}

func main() {
	o := Point{Coord{3, 4}, 5}
	println(o.dist())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method3() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

type Point struct {
	Coord
	z int
}

func main() {
	o := Point{Coord{3, 4}, 5}
	println(o.Coord.dist())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method4() {
	src := `
package main

type Coord struct {
	x, y int
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }

type Point struct {
	Coord
	z int
}

type Tpoint struct {
	t int
	Point
}

func main() {
	o := Tpoint{0, Point{Coord{3, 4}, 5}}
	println(o.dist())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_method5() {
	src := `
package main

import "fmt"

type Foo struct {
}

func (Foo) Show() {
	fmt.Println("Foo Showed")
}

func (f Foo) Call() {
	fmt.Println("Foo Called")
	f.Show()
}

type Bar struct {
	Foo
}

type Baz struct {
	Foo
}

func (Baz) Call() {
	fmt.Println("Baz Called")
}

func (Baz) Show() {
	fmt.Println("Baz Showed")
}

func main() {
	Foo{}.Call()
	Bar{}.Call()
	Baz{}.Call()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Foo Called
	// Foo Showed
	// Foo Called
	// Foo Showed
	// Baz Called
}

func Example_method6() {
	src := `
package main

type Sample struct {
	Name string
}

func (s Sample) foo(i int) {
	println("in foo", s.Name, i)
}

var samples = []Sample{
	Sample{"hello"},
}

func main() {
	samples[0].foo(3)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// in foo hello 3
}

func Example_method7() {
	src := `
package main

type Sample struct {
	Name string
}

func (s *Sample) foo(i int) {
	println("in foo", s.Name, i)
}

var samples = []Sample{
	Sample{"hello"},
}

func main() {
	samples[0].foo(3)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// in foo hello 3
}

func Example_method8() {
	src := `
package main

type Sample struct {
	Name string
	Foo  []string
}

func (s *Sample) foo(j int) {
	for i, v := range s.Foo {
		println(i, v)
	}
}

var samples = []Sample{
	Sample{"hello", []string{"world"}},
}

func main() {
	samples[0].foo(3)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 world
}

func Example_method9() {
	src := `
package main

type Coord struct {
	x, y int
}

func main() {
	o := Coord{3, 4}
	println(o.dist())
}

func (c Coord) dist() int { return c.x*c.x + c.y*c.y }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 25
}

func Example_neg0() {
	src := `
package main

import "fmt"

func main() {
	a := -1
	fmt.Println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// -1
}

func Example_op0() {
	src := `
package main

import "fmt"

func main() {
	var a, b, c uint16
	a = 64
	b = 64
	c = a * b
	fmt.Printf("c: %v %T", c, c)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// c: 4096 uint16
}

func Example_op1() {
	src := `
package main

func main() {
	var a int = 3
	a += 1.3
	println(a)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_op2() {
	src := `
package main

import "fmt"

func main() {
	a := 64
	a += 64
	fmt.Printf("a: %v %T", a, a)
	fmt.Println()

	b := 64
	b -= 64
	fmt.Printf("b: %v %T", b, b)
	fmt.Println()

	c := 64
	c *= 64
	fmt.Printf("c: %v %T", c, c)
	fmt.Println()

	d := 64
	d /= 64
	fmt.Printf("d: %v %T", d, d)
	fmt.Println()

	e := 64
	e %= 64
	fmt.Printf("e: %v %T", e, e)
	fmt.Println()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// a: 128 int
	// b: 0 int
	// c: 4096 int
	// d: 1 int
	// e: 0 int
}

func Example_ptr0() {
	src := `
package main

type myint int

func main() {
	var a myint = 2
	var b *myint = &a
	println(*b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
}

func Example_ptr1() {
	src := `
package main

func main() {
	var a int = 2
	b := &a
	println(*b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
}

func Example_ptr2() {
	src := `
package main

func f(i *int) {
	*i = *i + 3
}

func main() {
	var a int = 2
	f(&a)
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
}

func Example_ptr3() {
	src := `
package main

func f(i *int) {
	*i++
}

func main() {
	var a int = 2
	f(&a)
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_ptr4() {
	src := `
package main

type Foo struct {
	val int
}

func f(p *Foo) {
	p.val = p.val + 2
}

func main() {
	var a = Foo{3}
	f(&a)
	println(a.val)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
}

func Example_ptr5() {
	src := `
package main

type Foo struct {
	val int
}

func main() {
	var a = &Foo{3}
	println(a.val)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_ptr5a() {
	src := `
package main

type Foo struct {
	val int
}

func main() {
	var a = Foo{3}
	b := &a
	println(b.val)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_ptr6() {
	src := `
package main

type Foo struct {
	val int
}

func main() {
	var a = Foo{3}
	b := &a
	println(b.val)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}

func Example_recover0() {
	src := `
package main

import "fmt"

func main() {
	println("hello")
	defer func() {
		r := recover()
		fmt.Println("recover:", r)
	}()
	println("world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
	// world
	// recover: <nil>
}

func Example_recover1() {
	src := `
package main

import "fmt"

func main() {
	println("hello")
	defer func() {
		r := recover()
		fmt.Println("recover:", r)
	}()
	panic("test panic")
	println("world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
	// recover: test panic
}

func Example_ret1() {
	src := `
package main

func f(i int) (o int) { o = i + 1; return }

func main() { println(f(4)) }`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_ret2() {
	src := `
package main

func r2() (int, int) { return 1, 2 }

func main() {
	a, b := r2()
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 2
}

func Example_ret3() {
	src := `
package main

import "fmt"

func r2() (int, int) { return 1, 2 }

func main() {
	fmt.Println(r2())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 2
}

func Example_ret4() {
	src := `
package main

func r() int { return 1 }

func main() {
	a := r()
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_ret5() {
	src := `
package main

func r2() (int, int) { return 1, 2 }

var a, b int = r2()

func main() { println(a, b) }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1 2
}

func Example_run0() {
	src := `
package main

import "fmt"

func f() (int, int) { return 2, 3 }

func main() {
	fmt.Println(f())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2 3
}

func Example_run1() {
	src := `
package main

func f() (int, int) { return 2, 3 }

func g(i, j int) int { return i + j }

func main() {
	println(g(f()))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5
}

func Example_run10() {
	src := `
package main

func main() {
	func() { println("hello") }()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
}

func Example_run11() {
	src := `
package main

import "fmt"

func main() {
	fmt.Println(f())
}

func f() (int, int) { return 2, 3 }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2 3
}

func Example_run12() {
	src := `
package main

func f(a int) (int, int) {
	return a + 1, a + 2
}

func main() {
	a, b := f(3)
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 4 5
}

func Example_run13() {
	src := `
package main

func main() {
	a, b := f(3)
	println(a, b)
}

func f(a int) (int, int) {
	return a + 1, a + 2
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 4 5
}

func Example_run4() {
	src := `
package main

type fn func(int)

func f1(i int) { println("f1", i) }

func test(f fn, v int) { f(v) }

func main() { test(f1, 21) }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21
}

func Example_run5() {
	src := `
package main

type fn func(int)

func test(f fn, v int) { f(v) }

func main() {
	f1 := func(i int) { println("f1", i) }
	test(f1, 21)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21
}

func Example_run6() {
	src := `
package main

type fn func(int)

func test(f fn, v int) { f(v) }

func main() {
	test(func(i int) { println("f1", i) }, 21)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21
}

func Example_run7() {
	src := `
package main

type fn func(int)

func test(f fn, v int) { f(v) }

func main() {
	a := 3
	test(func(i int) { println("f1", i, a) }, 21)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21 3
}

func Example_run8() {
	src := `
package main

func main() {
	a := 3
	f := func(i int) { println("f1", i, a) }
	f(21)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21 3
}

func Example_run9() {
	src := `
package main

func main() {
	a := 3
	f := func(i int) int { println("f1", i, a); return i + 1 }
	b := f(21)
	println(b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// f1 21 3
	// 22
}

func Example_rune0() {
	src := `
package main

import "fmt"

func main() {
	a := 'r'
	a += 'g'
	fmt.Printf("a: %v %T", a, a)
	fmt.Println()

	b := 'r'
	b -= 'g'
	fmt.Printf("b: %v %T", b, b)
	fmt.Println()

	c := 'r'
	c *= 'g'
	fmt.Printf("c: %v %T", c, c)
	fmt.Println()

	d := 'r'
	d /= 'g'
	fmt.Printf("d: %v %T", d, d)
	fmt.Println()

	e := 'r'
	e %= 'g'
	fmt.Printf("e: %v %T", e, e)
	fmt.Println()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// a: 217 int32
	// b: 11 int32
	// c: 11742 int32
	// d: 1 int32
	// e: 11 int32
}

func Example_scope0() {
	src := `
package main

var a int = 1

func main() {
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
}

func Example_scope1() {
	src := `
package main

func f(a int) int {
	return 2*a + 1
}

var b int = f(3)

func main() {
	println(b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7
}

func Example_scope2() {
	src := `
package main

var a int = 1

func f() { println(a) }

func main() {
	println(a)
	a := 2
	println(a)
	f()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
	// 2
	// 1
}

func Example_scope3() {
	src := `
package main

func main() {
	a := 1
	if a := 2; a > 0 {
		println(a)
	}
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 1
}

func Example_scope4() {
	src := `
package main

func main() {
	a := 1
	if a := 2; a > 0 {
		println(a)
	}
	{
		a := 3
		println(a)
	}
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 3
	// 1
}

func Example_scope5() {
	src := `
package main

var a int = 1

func f() { println(a) }

func main() {
	println(a)
	a = 2
	println(a)
	f()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1
	// 2
	// 2
}

func Example_scope6() {
	src := `
package main

import "fmt"

var a = [3]int{1, 2, 3}

func f() { fmt.Println(a) }

func main() {
	fmt.Println(a)
	a[1] = 5
	f()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1 2 3]
	// [1 5 3]
}

func Example_scope7() {
	src := `
package main

import "fmt"

var a = []int{1, 2, 3}

func f() { fmt.Println(a) }

func main() {
	fmt.Println(a)
	a = []int{6, 7}
	f()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1 2 3]
	// [6 7]
}

func Example_select() {
	src := `
package main

import "time"
import "fmt"

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		time.Sleep(1e9)
		c1 <- "one"
	}()
	go func() {
		time.Sleep(2e9)
		c2 <- "two"
	}()

	for i := 0; i < 2; i++ {
		fmt.Println("start for")
		select {
		case msg1 := <-c1:
			fmt.Println("received", msg1)
			fmt.Println("finish 1")
		case msg2 := <-c2:
			fmt.Println("received #2", msg2)
		}
		fmt.Println("end for")
	}
	fmt.Println("Bye")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_select0() {
	src := `
package main

import "time"

func forever() {
	select {} // block forever
	println("end")
}

func main() {
	go forever()
	time.Sleep(1e9)
	println("bye")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_select1() {
	src := `
package main

import "time"
import "fmt"

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		time.Sleep(1e9)
		c1 <- "one"
	}()
	go func() {
		time.Sleep(2e9)
		c2 <- "two"
	}()

	for i := 0; i < 2; i++ {
		fmt.Println("start for")
		select {
		case msg1 := <-c1:
			fmt.Println("received", msg1)
			fmt.Println("finish 1")
		case msg2, ok := <-c2:
			fmt.Println("received #2", msg2, ok)
		}
		fmt.Println("end for")
	}
	fmt.Println("Bye")
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_select2() {
	src := `
package main

import (
	"fmt"
)

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		toSend := "hello"
		select {
		case c2 <- toSend:
			fmt.Println("Sent", toSend, "to c2")
		}
	}()

	select {
	case msg1 := <-c1:
		fmt.Println("received from c1:", msg1)
	case msg2 := <-c2:
		fmt.Println("received from c2:", msg2)
	}
	fmt.Println("Bye")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Sent hello to c2
	// received from c2: hello
	// Bye
}

func Example_select3() {
	src := `
package main

func main() {
	select {
	default:
		println("no comm")
	}
	println("bye")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// no comm
	// bye
}

func Example_server() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

var v string = "v1.0"

func main() {
	a := "hello "
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Welcome to my website! ", a, v)
	})

	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server0() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

var v string = "v1.0"

func myHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Welcome to my website!")
}

func main() {
	http.HandleFunc("/", myHandler)
	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server1() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

var version string = "1.0"

type Middleware struct {
	Name string
}

func (m *Middleware) Handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Welcome to my website", m.Name, version)
}

func main() {
	m := &Middleware{"Test"}
	http.HandleFunc("/", m.Handler)
	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server1a() {
	src := `
package main

import (
	"fmt"
	"log"
	"net/http"
)

var v string = "v1.0"

type Middleware struct {
	Name string
}

func (m *Middleware) Handler(w http.ResponseWriter, r *http.Request) {
	log.Println(r.Header.Get("User-Agent"))
	w.Header().Set("test", "ok")
	log.Println(w.Header())
	fmt.Fprintln(w, "Welcome to my website", m.Name)
}

func main() {
	m := &Middleware{"Test"}
	http.HandleFunc("/", m.Handler)
	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server2() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

var v string = "v1.0"

func main() {

	myHandler := func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "Welcome to my website!")
	}

	http.HandleFunc("/", myHandler)
	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server3() {
	src := `
package main

import (
	"net/http"
)

var myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("hello world")) })

func main() {
	http.HandleFunc("/", myHandler)
	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server4() {
	src := `
package main

import (
	"net/http"
)

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Welcome to my website!"))
	})

	http.ListenAndServe(":8080", nil)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server5() {
	src := `
package main

import (
	"net/http"
)

var myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("hello world"))
})

func main() {
	http.ListenAndServe(":8080", myHandler)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_server6() {
	src := `
package main

import (
	"fmt"
	"net/http"
)

var myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("hello world"))
})

type T1 struct {
	Name string
}

func (t *T1) Handler(h http.Handler) http.Handler {
	fmt.Println("#1", t.Name)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Println("#2", t.Name)
		h.ServeHTTP(w, r)
	})
}

func main() {
	t := &T1{"myName"}
	handler := t.Handler(myHandler)
	http.ListenAndServe(":8080", handler)
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_sieve() {
	src := `
// A concurrent prime sieve

package main

// Send the sequence 2, 3, 4, ... to channel 'ch'.
func Generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i // Send 'i' to channel 'ch'.
	}
}

// Copy the values from channel 'in' to channel 'out',
// removing those divisible by 'prime'.
func Filter(in <-chan int, out chan<- int, prime int) {
	for {
		i := <-in // Receive value from 'in'.
		if i%prime != 0 {
			out <- i // Send 'i' to 'out'.
		}
	}
}

// The prime sieve: Daisy-chain Filter processes.
func main() {
	ch := make(chan int) // Create a new channel.
	go Generate(ch)      // Launch Generate goroutine.

	for i := 0; i < 10; i++ {
		prime := <-ch
		println(prime)
		ch1 := make(chan int)
		go Filter(ch, ch1, prime)
		ch = ch1
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
	// 3
	// 5
	// 7
	// 11
	// 13
	// 17
	// 19
	// 23
	// 29
}

func Example_str() {
	src := `
package main

func main() {
	println("hello world")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello world
}

func Example_struct() {
	src := `
package main

type T struct {
	f int
	g int
}

func main() {
	a := T{7, 8}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7 8
}

func Example_struct0() {
	src := `
package main

type T struct {
	f int
	g int
}

func main() {
	a := T{}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 0
}

func Example_struct0a() {
	src := `
package main

type T struct {
	f int
}

func main() {
	a := T{}
	println(a.f)
	a.f = 8
	println(a.f)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0
	// 8
}

func Example_struct1() {
	src := `
package main

type T struct {
	f int
	g struct {
		h int
	}
}

func main() {
	a := T{}
	a.g.h = 3 + 2
	println("a.g.h", a.g.h)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// a.g.h 5
}

func Example_struct10() {
	src := `
package main

type T struct {
	f int
	g int64
}

func main() {
	a := T{g: 8}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 8
}

func Example_struct2() {
	src := `
package main

type T struct {
	f int
	g int
}

func main() {
	a := T{g: 8, f: 7}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7 8
}

func Example_struct3() {
	src := `
package main

type T struct {
	f int
	g int
	h struct {
		k int
	}
}

func f(i int) int { return i + 3 }

func main() {
	a := T{}
	a.h.k = f(4)
	println(a.h.k)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7
}

func Example_struct4() {
	src := `
package main

type T3 struct {
	k int
}

type T2 struct {
	h int
	T3
}

type T struct {
	f int
	g int
	T2
}

func f(i int) int { return i * i }

func main() {
	a := T{5, 7, T2{f(8), T3{9}}}
	println(a.f, a.g, a.h, a.k)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5 7 64 9
}

func Example_struct5() {
	src := `
package main

type T struct {
	f int
	g int
}

func f(i int) int { return i * i }

func main() {
	a := T{7, f(4)}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7 16
}

func Example_struct6() {
	src := `
package main

type T struct {
	f, g int
}

func main() {
	a := T{7, 8}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7 8
}

func Example_struct7() {
	src := `
package main

type Opt struct {
	b bool
}

type T struct {
	i   int
	opt Opt
}

func main() {
	a := T{}
	println(a.i, a.opt.b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 false
}

func Example_struct8() {
	src := `
package main

type T3 struct {
	k int
}

type T2 struct {
	h int
	T3
}

type T struct {
	f int
	g int
	T2
}

func f(i int) int { return i * i }

func main() {
	a := T{5, 7, T2{8, T3{9}}}
	println(a.f, a.g, a.T2.h, a.T2.T3.k)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 5 7 8 9
}

func Example_struct9() {
	src := `
package main

type T struct {
	f int
	g int64
}

func main() {
	a := T{7, 8}
	println(a.f, a.g)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 7 8
}

func Example_switch() {
	src := `
package main

func main() {
	a := 3
	switch a {
	case 0:
		println(200)
	default:
		println(a)
	case 3:
		println(100)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 100
}

func Example_time0() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println(time.Now())
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_time1() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Date(2009, time.November, 10, 23, 4, 5, 0, time.UTC)
	m := t.Minute()
	fmt.Println(t, m)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2009-11-10 23:04:05 +0000 UTC 4
}

func Example_time2() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Date(2009, time.November, 10, 23, 4, 5, 0, time.UTC)
	h, m, s := t.Clock()
	fmt.Println(h, m, s)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 23 4 5
}

func Example_time3() {
	src := `
package main

import (
	"fmt"
	"time"
)

// FIXME related to named returns
func main() {
	t := time.Date(2009, time.November, 10, 23, 4, 5, 0, time.UTC)
	fmt.Println(t.Clock())
}`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

}

func Example_time4() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	var m time.Month
	m = 9
	fmt.Println(m)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// September
}

func Example_time5() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Unix(1e9, 0)
	fmt.Println(t.Minute())
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 46
}

func Example_time6() {
	src := `
package main

import (
	"fmt"
	"time"
)

func main() {
	t := &time.Time{}
	t.UnmarshalText([]byte("1985-04-12T23:20:50.52Z"))

	fmt.Println(t)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 1985-04-12 23:20:50.52 +0000 UTC
}

func Example_time7() {
	src := `
package main

import (
	"fmt"
	"time"
)

var d = 2 * time.Second

func main() { fmt.Println(d) }
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2s
}

func Example_type0() {
	src := `
package main

type newInt int

func main() {
	var a newInt
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0
}

func Example_type1() {
	src := `
package main

import "fmt"

func main() {
	var i interface{} = "hello"
	s := i.(string)
	fmt.Println(s)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello
}

func Example_type2() {
	src := `
package main

import (
	"fmt"
	"time"
)

type Options struct {
	debug bool
}

type T1 struct {
	opt  Options
	time time.Time
}

func main() {
	t := T1{}
	t.time = time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
	fmt.Println(t.time)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2009-11-10 23:00:00 +0000 UTC
}

func Example_type3() {
	src := `
package main

import "fmt"

type S1 string

func main() {
	s := S1("Hello")
	fmt.Println(s)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// Hello
}

func Example_type4() {
	src := `
package main

import (
	"fmt"
	"reflect"
)

func main() {
	a := int32(12)
	fmt.Println(reflect.TypeOf(a))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// int32
}

func Example_type5() {
	src := `
package main

import (
	"fmt"
	"reflect"
)

type T int

func main() {
	a := T(12)
	fmt.Println(reflect.TypeOf(a))
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// int
}

func Example_type6() {
	src := `
package main

import (
	"fmt"
	"reflect"
)

func main() {
	a := T(12)
	fmt.Println(reflect.TypeOf(a))
}

type T int
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// int
}

func Example_type7() {
	src := `
package main

import "fmt"

func main() {
	var i interface{} = "hello"
	if s, ok := i.(string); ok {
		fmt.Println(s, ok)
	}
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello true
}

func Example_var() {
	src := `
package main

func main() {
	var a, b, c int
	println(a, b, c)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 0 0 0
}

func Example_var2() {
	src := `
package main

func main() {
	var a int = 2
	println(a)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2
}

func Example_var3() {
	src := `
package main

func main() {
	var a, b int = 2, 3
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2 3
}

func Example_var4() {
	src := `
package main

func main() {
	var a, b = 2, 3
	println(a, b)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 2 3
}

func Example_var5() {
	src := `
package main

import "fmt"

func main() {
	var a int64 = 64
	fmt.Printf("a: %v %T", a, a)
	fmt.Println()
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// a: 64 int64
}

func Example_variadic() {
	src := `
package main

import "fmt"

func f(a ...int) {
	fmt.Println(a)
}

func main() {
	f(1, 2, 3, 4)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// [1 2 3 4]
}

func Example_variadic0() {
	src := `
package main

import "fmt"

func f(s string, a ...int) {
	fmt.Println(s, a)
}

func main() {
	f("hello")
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello []
}

func Example_variadic1() {
	src := `
package main

import "fmt"

func f(s string, a ...int32) {
	fmt.Println(s, a)
}

func main() {
	f("hello", 1, 2, 3)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// hello [1 2 3]
}

func Example_variadic2() {
	src := `
package main

import "fmt"

func f(a ...int) {
	if len(a) > 2 {
		fmt.Println(a[2])
	}
}

func main() {
	f(1, 2, 3, 4)
}
`
	i := interp.New(interp.Opt{Entry: "main"})
	i.Use(stdlib.Value, stdlib.Type)
	_, err := i.Eval(src)
	if err != nil {
		panic(err)
	}

	// Output:
	// 3
}
