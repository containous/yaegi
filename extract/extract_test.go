package extract

import (
	"bytes"
	"os"
	"path"
	"path/filepath"
	"strings"
	"testing"
)

var foobazExportTemplate = `// Code generated by 'goexports guthib.com/baz'. DO NOT EDIT.

// +build go1.14,!go1.15

package PKGNAME

import (
	"guthib.com/baz"
	"reflect"
)

func init() {
	Symbols["guthib.com/baz"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"Hello": reflect.ValueOf(baz.Hello),
	}
}
`

func foobazExport(pkgName string) string {
	return strings.Replace(foobazExportTemplate, "PKGNAME", pkgName, 1)
}

func TestPackages(t *testing.T) {
	testCases := []struct {
		desc     string
		wd       string
		goPath   string
		arg      string
		expected string
		contains string
		dest     string
	}{
		{
			desc:   "stdlib math pkg, still using go/importer",
			dest:   "math",
			goPath: "",
			arg:    "math",
			// We check this one because it shows both defects when we break it: the value
			// gets corrupted, and the type becomes token.INT
			// TODO(mpl): if the ident between key and value becomes annoying, be smarter about it.
			contains: `"MaxFloat64":             reflect.ValueOf(constant.MakeFromLiteral("179769313486231570814527423731704356798100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", token.FLOAT, 0)),`,
		},
		{
			desc:     "running from within pkg, using pkgname, dep in gopath",
			wd:       "./testdata/1/src/guthib.com/bar",
			goPath:   "./testdata/1",
			arg:      "guthib.com/baz",
			expected: foobazExport("bar"),
		},
		{
			desc:     "running from outside pkg, using pkgname, dep in gopath",
			wd:       "./testdata",
			goPath:   "./testdata/1",
			arg:      "guthib.com/baz",
			expected: foobazExport("testdata"),
		},
		{
			desc:     "running from within pkg, using relative path, dep in gopath",
			wd:       "./testdata/1/src/guthib.com/bar",
			goPath:   "./testdata/1",
			arg:      "./../baz",
			expected: foobazExport("bar"),
		},
		{
			desc:     "running from outside pkg, using relative path, dep in gopath",
			wd:       "./testdata",
			goPath:   "./testdata/1",
			arg:      "./1/src/guthib.com/baz",
			expected: foobazExport("testdata"),
		},
	}

	if err := os.Setenv("GO111MODULE", "off"); err != nil {
		t.Fatal(err)
	}
	for _, test := range testCases {
		test := test
		t.Run(test.desc, func(t *testing.T) {
			var goPath string
			if test.goPath != "" {
				var err error
				goPath, err = filepath.Abs(test.goPath)
				if err != nil {
					t.Fatal(err)
				}
			}
			if err := os.Setenv("GOPATH", goPath); err != nil {
				t.Fatal(err)
			}

			dest := path.Base(test.wd)
			if test.dest != "" {
				dest = test.dest
			}
			ext := Extractor{
				WorkingDir: test.wd,
				Dest:       dest,
			}

			var out bytes.Buffer
			if _, err := ext.Extract(test.arg, &out); err != nil {
				t.Fatal(err)
			}

			if test.expected != "" {
				if out.String() != test.expected {
					t.Fatalf("\nGot:\n%q\nWant: \n%q", out.String(), test.expected)
				}
			}

			if test.contains != "" {
				if !strings.Contains(out.String(), test.contains) {
					t.Fatalf("Missing expected part: %s IN %s", test.contains, out.String())
				}
			}
		})
	}
}
