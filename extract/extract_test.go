package extract

import (
	"bytes"
	"os"
	"path"
	"path/filepath"
	"strings"
	"testing"
)

var foobazExportTemplate = `// Code generated by 'goexports foo/baz'. DO NOT EDIT.

// +build go1.14,!go1.15

package PKGNAME

import (
	"foo/baz"
	"reflect"
)

func init() {
	Symbols["foo/baz"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"Hello": reflect.ValueOf(baz.Hello),
	}
}
`

func foobazExport(pkgName string) string {
	return strings.Replace(foobazExportTemplate, "PKGNAME", pkgName, 1)
}

func TestPackages(t *testing.T) {
	testCases := []struct {
		desc     string
		wd       string
		goPath   string
		arg      string
		expected string
	}{
		{
			desc:     "running from within pkg, using pkgname, dep in gopath",
			wd:       "./testdata/1/src/foo/bar",
			goPath:   "./testdata/1",
			arg:      "foo/baz",
			expected: foobazExport("bar"),
		},
		{
			desc:     "running from outside pkg, using pkgname, dep in gopath",
			wd:       "./testdata",
			goPath:   "./testdata/1",
			arg:      "foo/baz",
			expected: foobazExport("testdata"),
		},
		{
			desc:     "running from within pkg, using relative path, dep in gopath",
			wd:       "./testdata/1/src/foo/bar",
			goPath:   "./testdata/1",
			arg:      "./../baz",
			expected: foobazExport("bar"),
		},
		{
			desc:     "running from outside pkg, using relative path, dep in gopath",
			wd:       "./testdata",
			goPath:   "./testdata/1",
			arg:      "./1/src/foo/baz",
			expected: foobazExport("testdata"),
		},
	}

	if err := os.Setenv("GO111MODULE", "off"); err != nil {
		t.Fatal(err)
	}
	for _, test := range testCases {
		test := test
		t.Run(test.desc, func(t *testing.T) {
			var goPath string
			if test.goPath != "" {
				var err error
				goPath, err = filepath.Abs(test.goPath)
				if err != nil {
					t.Fatal(err)
				}
			}
			if err := os.Setenv("GOPATH", goPath); err != nil {
				t.Fatal(err)
			}

			ext := Extractor{
				WorkingDir: test.wd,
				Dest:       path.Base(test.wd),
			}

			var out bytes.Buffer
			if _, err := ext.Extract(test.arg, &out); err != nil {
				t.Fatal(err)
			}

			if out.String() != test.expected {
				t.Errorf("\nGot:\n%q\nWant: \n%q", out.String(), test.expected)
			}
		})
	}
}
