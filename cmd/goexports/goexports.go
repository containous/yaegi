//go:generate go build

// This program generates code to register binary program symbols to the interpreter.
// See stdlib.go for usage

package main

import (
	"bytes"
	"go/constant"
	"go/format"
	"go/importer"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path"
	"runtime"
	"strconv"
	"strings"
	"text/template"
)

const model = `// +build {{.CurrentGoVersion}},!{{.NextGoVersion}}
 
package {{.Dest}}

// Code generated by 'goexports {{.PkgName}}'. DO NOT EDIT.

import (
	"{{.PkgName}}"
	"reflect"
)

func init() {
	Value["{{.PkgName}}"] = map[string]reflect.Value{
		// function, constant and variable definitions
		{{range $key, $value := .Val -}}
			{{- if $value.Addr -}}
				"{{$key}}": reflect.ValueOf(&{{$value.Name}}).Elem(),
			{{else -}}
				"{{$key}}": reflect.ValueOf({{$value.Name}}),
			{{end -}}
		{{end}}

		// type definitions
		{{range $key, $value := .Typ -}}
			"{{$key}}": reflect.ValueOf((*{{$value}})(nil)),
		{{end}}
	}
	Wrapper["{{.PkgName}}"] = map[string]reflect.Type{
		{{range $key, $value := .Wrap -}}
			"{{$key}}": reflect.TypeOf((*w{{$key}})(nil)),
		{{end}}
	}
}
{{range $key, $value := .Wrap -}}
	// w{{$key}} is an interface wrapper for {{$key}} type
	type w{{$key}} struct {
		{{range $m := $value -}}
		W{{$m.Name}} {{$m.Type}}
		{{end}}
	}
	{{range $m := $value -}}
		func (w w{{$key}}) {{$m.Name}}{{$m.Param}} {{$m.Result}} { {{$m.Ret}} w.W{{$m.Name}}{{$m.Arg}} }
	{{end}}
{{end}}
`

// Val store the value name and addressable status of symbols
type Val struct {
	Name string // "package.name"
	Addr bool   // true if symbol is a Var
}

type Method struct {
	Name, Type, Param, Result, Arg, Ret string
}

func genContent(dest, pkgName string) ([]byte, error) {
	p, err := importer.For("source", nil).Import(pkgName)
	if err != nil {
		return nil, err
	}

	typ := map[string]string{}
	val := map[string]Val{}
	wrap := map[string][]Method{}
	sc := p.Scope()
	for _, name := range sc.Names() {
		o := sc.Lookup(name)
		if !o.Exported() {
			continue
		}
		pname := path.Base(pkgName) + "." + name
		switch o := o.(type) {
		case *types.Const:
			val[name] = Val{fixConst(pname, o.Val()), false}
		case *types.Func:
			val[name] = Val{pname, false}
		case *types.Var:
			val[name] = Val{pname, true}
		case *types.TypeName:
			typ[name] = pname
			switch t := o.Type().Underlying().(type) {
			case *types.Interface:
				wrap[name] = make([]Method, t.NumMethods())
				for i := range wrap[name] {
					f := t.Method(i)
					sig := f.Type().(*types.Signature)
					param := sig.Params().String()
					result := sig.Results().String()
					args := make([]string, sig.Params().Len())
					for i := range args {
						args[i] = sig.Params().At(i).Name()
					}
					arg := "(" + strings.Join(args, ", ") + ")"
					ret := ""
					if sig.Results().Len() > 0 {
						ret = "return"
					}
					wrap[name][i] = Method{f.Name(), f.Type().String(), param, result, arg, ret}
				}
			}
		}
	}

	parts := strings.Split(runtime.Version(), ".")
	currentGoVersion := parts[0] + "." + parts[1]

	minor, err := strconv.Atoi(parts[1])
	if err != nil {
		return nil, err
	}
	nextGoVersion := parts[0] + "." + strconv.Itoa(minor+1)

	base := template.New("goexports")
	parse, err := base.Parse(model)
	if err != nil {
		return nil, err
	}

	b := &bytes.Buffer{}
	data := map[string]interface{}{
		"Dest":             dest,
		"PkgName":          pkgName,
		"Val":              val,
		"Typ":              typ,
		"Wrap":             wrap,
		"CurrentGoVersion": currentGoVersion,
		"NextGoVersion":    nextGoVersion,
	}
	err = parse.Execute(b, data)
	if err != nil {
		return nil, err
	}

	// gofmt
	source, err := format.Source(b.Bytes())
	if err != nil {
		return nil, err
	}
	return source, nil
}

// fixConst checks untyped constant value, converting it if necessary to avoid overflow
func fixConst(name string, val constant.Value) string {
	if val.Kind() == constant.Int {
		str := val.ExactString()
		i, err := strconv.ParseInt(str, 0, 64)
		if err == nil {
			switch {
			case i == int64(int32(i)):
				return name
			case i == int64(uint32(i)):
				return "uint32(" + name + ")"
			default:
				return "int64(" + name + ")"
			}
		}
		_, err = strconv.ParseUint(str, 0, 64)
		if err == nil {
			return "uint64(" + name + ")"
		}
	}
	return name
}

func main() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	dest := path.Base(dir)

	for _, pkg := range os.Args[1:] {
		content, err := genContent(dest, pkg)
		if err != nil {
			log.Fatal(err)
		}

		var oFile string
		if pkg == "syscall" {
			os, arch := os.Getenv("GOOS"), os.Getenv("GOARCH")
			oFile = strings.Replace(pkg, "/", "_", -1) + "_" + os + "_" + arch + ".go"
		} else {
			oFile = strings.Replace(pkg, "/", "_", -1) + ".go"
		}

		parts := strings.Split(runtime.Version(), ".")

		err = ioutil.WriteFile(parts[0]+"_"+parts[1]+"_"+oFile, content, 0666)
		if err != nil {
			log.Fatal(err)
		}
	}
}
