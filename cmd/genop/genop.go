package main

import (
	"bytes"
	"io/ioutil"
	"log"
	"text/template"
)

const model = `package interp

// Code generated by 'go run ../cmd/genop/genop.go'. DO NOT EDIT.

import "reflect"

{{range $name, $op := .Ops}}
func {{$name}}(n *Node) {
	i := n.findex
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	{{- if $op.Str}}
	case reflect.String:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			f.data[i].SetString(v0(f).String() {{$op.Name}} v1(f).String())
			return next
		}
	{{- end}}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		{{- if $op.Shift}}
		v1 := genValueUint(n.child[1])
		{{else}}
		v1 := genValueInt(n.child[1])
		{{end -}}
		n.exec = func(f *Frame) Builtin {
			f.data[i].SetInt(v0(f) {{$op.Name}} v1(f))
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v0 := genValueUint(n.child[0])
		v1 := genValueUint(n.child[1])
		n.exec = func(f *Frame) Builtin {
			f.data[i].SetUint(v0(f) {{$op.Name}} v1(f))
			return next
		}
	{{- if $op.Float}}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		v1 := genValueFloat(n.child[1])
		n.exec = func(f *Frame) Builtin {
			f.data[i].SetFloat(v0(f) {{$op.Name}} v1(f))
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		v1 := genValue(n.child[1])
		n.exec = func(f *Frame) Builtin {
			f.data[i].SetComplex(v0(f).Complex() {{$op.Name}} v1(f).Complex())
			return next
		}
	{{- end}}
	}
}
{{end}}
`

type Op struct {
	Name  string
	Str   bool
	Float bool
	Shift bool
}

func main() {
	base := template.New("goexports")
	parse, err := base.Parse(model)
	if err != nil {
		log.Fatal(err)
	}

	b := &bytes.Buffer{}
	data := map[string]interface{}{
		"Ops": map[string]Op{
			"add":    Op{"+", true, true, false},
			"sub":    Op{"-", false, true, false},
			"mul":    Op{"*", false, true, false},
			"quo":    Op{"/", false, true, false},
			"rem":    Op{"%", false, false, false},
			"shl":    Op{"<<", false, false, true},
			"shr":    Op{">>", false, false, true},
			"and":    Op{"&", false, false, false},
			"or":     Op{"|", false, false, false},
			"xor":    Op{"^", false, false, false},
			"andnot": Op{"&^", false, false, false},
		},
	}
	if err = parse.Execute(b, data); err != nil {
		log.Fatal(err)
	}
	if err = ioutil.WriteFile("op.go", b.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}
}
