package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"text/template"
)

const model = `package interp

// Code generated by 'go run ../cmd/genop/genop.go'. DO NOT EDIT.

import "reflect"

// Arithmetic operators
{{range $name, $op := .Arithmetic}}
func {{$name}}(n *Node) {
	dest := genValue(n)
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()
	c0, c1 := n.child[0], n.child[1]

	switch typ.Kind() {
	{{- if $op.Str}}
	case reflect.String:
		switch {
		case c0.rval.IsValid():
			s0 := c0.rval.String()
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				dest(f).SetString(s0 {{$op.Name}} v1(f).String())
				return next
			}
		case c1.rval.IsValid():
			v0 := genValue(c0)
			s1 := c1.rval.String()
			n.exec = func(f *Frame) Builtin {
				dest(f).SetString(v0(f).String() {{$op.Name}} s1)
				return next
			}
		default:
			v0 := genValue(c0)
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				dest(f).SetString(v0(f).String() {{$op.Name}} v1(f).String())
				return next
			}
		}
	{{- end}}
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		switch {
		case c0.rval.IsValid():
			i := vInt(c0.rval)
			{{- if $op.Shift}}
			v1 := genValueUint(c1)
			{{else}}
			v1 := genValueInt(c1)
			{{end -}}
			n.exec = func(f *Frame) Builtin {
				_, j := v1(f)
				dest(f).SetInt(i {{$op.Name}} j)
				return next
			}
		case c1.rval.IsValid():
			v0 := genValueInt(c0)
			{{- if $op.Shift}}
			j := vUint(c1.rval)
			{{else}}
			j := vInt(c1.rval)
			{{end -}}
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				dest(f).SetInt(i {{$op.Name}} j)
				return next
			}
		default:
			v0 := genValueInt(c0)
			{{- if $op.Shift}}
			v1 := genValueUint(c1)
			{{else}}
			v1 := genValueInt(c1)
			{{end -}}
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				_, j := v1(f)
				dest(f).SetInt(i {{$op.Name}} j)
				return next
			}
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		switch {
		case c0.rval.IsValid():
			i := vUint(c0.rval)
			v1 := genValueUint(c1)
			n.exec = func(f *Frame) Builtin {
				_, j := v1(f)
				dest(f).SetUint(i {{$op.Name}} j)
				return next
			}
		case c1.rval.IsValid():
			j := vUint(c1.rval)
			v0 := genValueUint(c0)
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				dest(f).SetUint(i {{$op.Name}} j)
				return next
			}
		default:
			v0 := genValueUint(c0)
			v1 := genValueUint(c1)
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				_, j := v1(f)
				dest(f).SetUint(i {{$op.Name}} j)
				return next
			}
		}
	{{- if $op.Float}}
	case reflect.Float32, reflect.Float64:
		switch {
		case c0.rval.IsValid():
			i := vFloat(c0.rval)
			v1 := genValueFloat(c1)
			n.exec = func(f *Frame) Builtin {
				_, j := v1(f)
				dest(f).SetFloat(i {{$op.Name}} j)
				return next
			}
		case c1.rval.IsValid():
			j := vFloat(c1.rval)
			v0 := genValueFloat(c0)
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				dest(f).SetFloat(i {{$op.Name}} j)
				return next
			}
		default:
			v0 := genValueFloat(c0)
			v1 := genValueFloat(c1)
			n.exec = func(f *Frame) Builtin {
				_, i := v0(f)
				_, j := v1(f)
				dest(f).SetFloat(i {{$op.Name}} j)
				return next
			}
		}
	case reflect.Complex64, reflect.Complex128:
		switch {
		case c0.rval.IsValid():
			r0 := c0.rval.Complex()
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				dest(f).SetComplex(r0 {{$op.Name}} v1(f).Complex())
				return next
			}
		case c1.rval.IsValid():
			r1 := c1.rval.Complex()
			v0 := genValue(c0)
			n.exec = func(f *Frame) Builtin {
				dest(f).SetComplex(v0(f).Complex() {{$op.Name}} r1)
				return next
			}
		default:
			v0 := genValue(c0)
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				dest(f).SetComplex(v0(f).Complex() {{$op.Name}} v1(f).Complex())
				return next
			}
		}
	{{- end}}
	}
}
{{end}}
// Assign operators
{{range $name, $op := .Arithmetic}}
func {{$name}}Assign(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()
	c0, c1 := n.child[0], n.child[1]

	if c1.rval.IsValid() {
		switch typ.Kind() {
		{{- if $op.Str}}
		case reflect.String:
			v0 := genValueString(c0)
			v1 := c1.rval.String()
			n.exec = func(f *Frame) Builtin {
				v, s := v0(f)
				v.SetString(s {{$op.Name}} v1)
				return next
			}
		{{- end}}
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			v0 := genValueInt(c0)
			{{- if $op.Shift}}
			j := vUint(c1.rval)
			{{else}}
			j := vInt(c1.rval)
			{{end -}}
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				v.SetInt(i {{$op.Name}} j)
				return next
			}
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			v0 := genValueUint(c0)
			j := vUint(c1.rval)
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				v.SetUint(i {{$op.Name}} j)
				return next
			}
		{{- if $op.Float}}
		case reflect.Float32, reflect.Float64:
			v0 := genValueFloat(c0)
			j := vFloat(c1.rval)
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				v.SetFloat(i {{$op.Name}} j)
				return next
			}
		case reflect.Complex64, reflect.Complex128:
			v0 := genValue(c0)
			v1 := c1.rval.Complex()
			n.exec = func(f *Frame) Builtin {
				v := v0(f)
				v.SetComplex(v.Complex() {{$op.Name}} v1)
				return next
			}
		{{- end}}
		}
	} else {
		switch typ.Kind() {
		{{- if $op.Str}}
		case reflect.String:
			v0 := genValueString(c0)
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				v, s := v0(f)
				v.SetString(s {{$op.Name}} v1(f).String())
				return next
			}
		{{- end}}
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			v0 := genValueInt(c0)
			{{- if $op.Shift}}
			v1 := genValueUint(c1)
			{{else}}
			v1 := genValueInt(c1)
			{{end -}}
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				_, j := v1(f)
				v.SetInt(i {{$op.Name}} j)
				return next
			}
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			v0 := genValueUint(c0)
			v1 := genValueUint(c1)
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				_, j := v1(f)
				v.SetUint(i {{$op.Name}} j)
				return next
			}
		{{- if $op.Float}}
		case reflect.Float32, reflect.Float64:
			v0 := genValueFloat(c0)
			v1 := genValueFloat(c1)
			n.exec = func(f *Frame) Builtin {
				v, i := v0(f)
				_, j := v1(f)
				v.SetFloat(i {{$op.Name}} j)
				return next
			}
		case reflect.Complex64, reflect.Complex128:
			v0 := genValue(c0)
			v1 := genValue(c1)
			n.exec = func(f *Frame) Builtin {
				v := v0(f)
				v.SetComplex(v.Complex() {{$op.Name}} v1(f).Complex())
				return next
			}
		{{- end}}
		}
	}
}
{{end}}
{{range $name, $op := .IncDec}}
func {{$name}}(n *Node) {
	next := getExec(n.tnext)
	typ := n.typ.TypeOf()

	switch typ.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		v0 := genValueInt(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetInt(i {{$op.Name}} 1)
			return next
		}
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		v0 := genValueUint(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetUint(i {{$op.Name}} 1)
			return next
		}
	case reflect.Float32, reflect.Float64:
		v0 := genValueFloat(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v, i := v0(f)
			v.SetFloat(i {{$op.Name}} 1)
			return next
		}
	case reflect.Complex64, reflect.Complex128:
		v0 := genValue(n.child[0])
		n.exec = func(f *Frame) Builtin {
			v := v0(f)
			v.SetComplex(v.Complex() {{$op.Name}} 1)
			return next
		}
	}
}
{{end}}
{{range $name, $op := .Comparison}}
func {{$name}}(n *Node) {
	tnext := getExec(n.tnext)
	c0, c1 := n.child[0], n.child[1]

	switch t0, t1 := c0.typ, c1.typ; {
	case isString(t0) || isString(t1):
		switch {
		case c0.rval.IsValid():
			s0 := c0.rval.String()
			v1 := genValueString(n.child[1])
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				i := n.findex
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					f.data[i].SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		case c1.rval.IsValid():
			s1 := c1.rval.String()
			v0 := genValueString(n.child[0])
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				i := n.findex
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					f.data[i].SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		default:
			v0 := genValueString(n.child[0])
			v1 := genValueString(n.child[1])
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				i := n.findex
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					f.data[i].SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		}
	case isFloat(t0) || isFloat(t1):
		switch {
		case c0.rval.IsValid():
			s0 := vFloat(c0.rval)
			v1 := genValueFloat(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		case c1.rval.IsValid():
			s1 := vFloat(c1.rval)
			v0 := genValueFloat(c0)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		default:
			v0 := genValueFloat(c0)
			v1 := genValueFloat(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		}
	case isUint(t0) || isUint(t1):
		switch {
		case c0.rval.IsValid():
			s0 := vUint(c0.rval)
			v1 := genValueUint(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		case c1.rval.IsValid():
			s1 := vUint(c1.rval)
			v0 := genValueUint(c0)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		default:
			v0 := genValueUint(c0)
			v1 := genValueUint(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		}
	case isInt(t0) || isInt(t1):
		switch {
		case c0.rval.IsValid():
			s0 := vInt(c0.rval)
			v1 := genValueInt(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		case c1.rval.IsValid():
			s1 := vInt(c1.rval)
			v0 := genValueInt(c0)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		default:
			v0 := genValueInt(c0)
			v1 := genValueInt(c1)
			if n.fnext != nil {
				fnext := getExec(n.fnext)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					if s0 {{$op.Name}} s1 {
						return tnext
					}
					return fnext
				}
			} else {
				dest := genValue(n)
				n.exec = func(f *Frame) Builtin {
					_, s0 := v0(f)
					_, s1 := v1(f)
					dest(f).SetBool(s0 {{$op.Name}} s1)
					return tnext
				}
			}
		}
	}
}
{{end}}
`

// Op define operator name and properties
type Op struct {
	Name  string // +, -, ...
	Str   bool   // true if operator applies to string
	Float bool   // true if operator applies to float
	Shift bool   // true if operator is a shift operation
}

func main() {
	base := template.New("goexports")
	parse, err := base.Parse(model)
	if err != nil {
		log.Fatal(err)
	}

	b := &bytes.Buffer{}
	data := map[string]interface{}{
		"Arithmetic": map[string]Op{
			"add":    {"+", true, true, false},
			"sub":    {"-", false, true, false},
			"mul":    {"*", false, true, false},
			"quo":    {"/", false, true, false},
			"rem":    {"%", false, false, false},
			"shl":    {"<<", false, false, true},
			"shr":    {">>", false, false, true},
			"and":    {"&", false, false, false},
			"or":     {"|", false, false, false},
			"xor":    {"^", false, false, false},
			"andnot": {"&^", false, false, false},
		},
		"IncDec": map[string]Op{
			"inc": {Name: "+"},
			"dec": {Name: "-"},
		},
		"Comparison": map[string]Op{
			"equal":        {Name: "=="},
			"greater":      {Name: ">"},
			"greaterEqual": {Name: ">="},
			"lower":        {Name: "<"},
			"lowerEqual":   {Name: "<="},
			"notEqual":     {Name: "!="},
		},
	}
	if err = parse.Execute(b, data); err != nil {
		log.Fatal(err)
	}

	// gofmt
	source, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err = ioutil.WriteFile("op.go", source, 0666); err != nil {
		log.Fatal(err)
	}
}
